Суть завдання

Потрібно написати  CAN-драйвер для STM32, який буде:
	1.	Приймати команди від комп’ютера (PC) через CAN.
	2.	Передавати назад телеметрію та heartbeat.
	3.	Керувати актуатором (через драйвер BTN7971B) та читати його положення з потенціометра.

При цьому:
	•	CAN-протокол вже повністю описаний у файлі automate.h / automate.c, які згенеровані з DBC за допомогою cantools.
	•	Керування двигуном здійснюється через BTN7971B

1. CAN-драйвер на STM32
	•	Налаштувати CAN на:
	•	500 кбіт/с
	•	розширені (29-бітні) ID
	•	Реалізувати прийом і передачу кадрів.
	•	Використати переривання + кільцевий буфер (або RTOS-черги — необов’язково).

2. Обробку CAN-повідомлень. Використовуючи функції з automate.c:

PC → MCU
	1.	Heart_Beat_MSG
	2.	Left_Brake_CMD – команда на натискання/відпускання

MCU → PC
	3.	Heart_Beat_MSG
	4.	Left_Brake_MSG – фактичний стан актуатора

Вам потрібно:
	•	розпаковувати отримані CAN-повідомлення,
	•	реагувати на команду Left_Brake_CMD,
	•	періодично відправляти Heartbeat та телеметрію.

3. Керування актуатором через BTN7971B

Потрібно зробити мінімальну логіку:
	•	якщо прийшла команда “натиснути” — увімкнути мотор у відповідний напрямок;
	•	якщо “відпустити” — у протилежний;
	•	зчитувати поточне положення актуатора через потенціометр;
	•	оновлювати статуси (Pushing / Released / Time_to_end_operation).

Коротко

Треба реалізувати базовий CAN-вузол на STM32, який:
	1.	Користується згенерованими структурам та функціями automate.h/c.
	2.	Приймає heartbeat та команди керування актуатором.
	3.	Передає heartbeat та стан актуатора назад на PC.
	4.	Керує мотором через драйвер BTN7971B.
	5.	Читає положення актуатора через потенціометр.
	6.	Працює на 500 кбіт/с, 29-бітні ID.
